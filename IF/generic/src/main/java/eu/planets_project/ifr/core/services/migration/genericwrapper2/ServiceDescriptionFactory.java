package eu.planets_project.ifr.core.services.migration.genericwrapper2;

import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import eu.planets_project.ifr.core.services.migration.genericwrapper2.exceptions.ConfigurationException;
import eu.planets_project.ifr.core.services.migration.genericwrapper2.exceptions.MigrationPathConfigException;
import eu.planets_project.services.datatypes.Parameter;
import eu.planets_project.services.datatypes.Property;
import eu.planets_project.services.datatypes.ServiceDescription;
import eu.planets_project.services.datatypes.Tool;
import eu.planets_project.services.datatypes.Property.Builder;
import eu.planets_project.services.migrate.Migrate;

/**
 * Factory for construction of
 * <code>{@link eu.planets_project.services.datatypes.ServiceDescription}</code>
 * instances from a generic wrapper configuration document.
 * 
 * @author Pelle Kofod &lt;pko@statsbiblioteket.dk&gt;
 * @author Thomas Skou Hansen &lt;tsh@statsbiblioteket.dk&gt;
 */
class ServiceDescriptionFactory {

    private Logger log = Logger.getLogger(ServiceDescriptionFactory.class
	    .getName());

    private final XPathFactory xPathFactory;

    private final Document configuration;
    private final String canonicalServiceName;
    private final String serviceProvider;

    /**
     * Create a factory which creates
     * <code>{@link eu.planets_project.services.datatypes.ServiceDescription}</code>
     * instances based on the in configuration formation provided by
     * <code>wrapperConfiguration</code>. The dynamic information
     * <code>canonicalServiceName</code> and <code>serviceProvider</code> is
     * also used for the construction of the <code>ServiceDescription</code>
     * instances, however, they must be provided by the concrete service which
     * applies the generic wrapper framework.
     * 
     * @param canonicalServiceName
     *            Canonical class name of the service utilising this factory
     *            instance.
     * @param serviceProvider
     *            Identifier for the organisation providing the service, i.e.
     *            the organisation that hosts the running service instance.
     * @param wrapperConfiguration
     *            A generic wrapper configuration document containing a service
     *            description element with the necessary information for
     *            creation of <code>ServiceDescription</code> instances.
     */
    ServiceDescriptionFactory(String canonicalServiceName,
	    String serviceProvider, Document wrapperConfiguration) {

	xPathFactory = XPathFactory.newInstance();
	configuration = wrapperConfiguration;
	this.serviceProvider = serviceProvider;
	this.canonicalServiceName = canonicalServiceName;
    }

    /**
     * Get a new
     * <code>{@link eu.planets_project.services.datatypes.ServiceDescription}</code>
     * instance, created from the information provided at the construction time
     * of this factory.
     * 
     * @return The created <code>ServiceDescription</code> instance.
     * @throws ConfigurationException
     *             if any errors are encountered in the configuration file while
     *             parsing it.
     */
    ServiceDescription getServiceDescription() throws ConfigurationException {

	final XPath pathsXPath = xPathFactory.newXPath();
	try {
	    final Node serviceDescriptionNode = (Node) pathsXPath.evaluate(
		    ConfigurationFileTagsV1.SERVICE_DESCRIPTION_ELEMENT_XPATH,
		    configuration, XPathConstants.NODE);

	    final String title = getMandatoryElementText(
		    serviceDescriptionNode,
		    ConfigurationFileTagsV1.TITLE_ELEMENT);

	    // Start the creation of a service description for a migration
	    // service.
	    ServiceDescription.Builder builder = new ServiceDescription.Builder(
		    title, Migrate.class.getCanonicalName());

	    Property[] serviceProperties = getServiceProperties(serviceDescriptionNode);

	    builder.author(getMandatoryElementText(serviceDescriptionNode,
		    ConfigurationFileTagsV1.CREATOR_ELEMENT));

	    builder.classname(canonicalServiceName);

	    // builder.endpoint() must not be called. The end-point information
	    // will be autogenerated.

	    builder.description(getOptionalElementText(serviceDescriptionNode,
		    ConfigurationFileTagsV1.DESCRIPTION_ELEMENT));

	    builder.identifier(getOptionalElementText(serviceDescriptionNode,
		    ConfigurationFileTagsV1.IDENTIFIER_ELEMENT));

	    builder.instructions(getOptionalElementText(serviceDescriptionNode,
		    ConfigurationFileTagsV1.INSTRUCTIONS_ELEMENT));

	    builder.version(getOptionalElementText(serviceDescriptionNode,
		    ConfigurationFileTagsV1.VERSION_ELEMENT));

	    builder.furtherInfo(getOptionalElementURI(serviceDescriptionNode,
		    ConfigurationFileTagsV1.FURTHER_INFO_ELEMENT));

	    builder.logo(getOptionalElementURI(serviceDescriptionNode,
		    ConfigurationFileTagsV1.LOGO_ELEMENT));

	    builder.serviceProvider(serviceProvider);

	    builder.tool(getToolDescriptionElement(serviceDescriptionNode));

	    eu.planets_project.services.datatypes.MigrationPath planetsPaths[] = getPlanetsMigrationPaths(configuration);
	    builder.paths(planetsPaths);

	    builder.inputFormats(getInputFormats(planetsPaths));

	    final List<Parameter> parameters = getUniqueParameters(planetsPaths);
	    builder.parameters(parameters);

	    builder.properties(serviceProperties);

	    return builder.build();
	} catch (XPathExpressionException xPathExpressionException) {
	    throw new ConfigurationException(String.format(
		    "Failed parsing the '%s' element in the '%s' element.",
		    ConfigurationFileTagsV1.SERVICE_DESCRIPTION_ELEMENT_XPATH,
		    configuration.getNodeName()), xPathExpressionException);
	}
    }

    /**
     * Return the text content of the optional element with the name specified
     * by <code>elementName</code> in <code>nodeWithOptionalElement</code> or
     * <code>null</code> if it is missing.
     * 
     * @param nodeWithOptionalElement
     *            <code>Node</code> that may contain an optional (child) element
     *            with the name specified by <code>elementName</code>.
     * 
     * @param elementName
     *            name of the optional element to parse.
     * 
     * @return a <code>String</code> instance containing the text content of the
     *         optional element or <code>null</code> if it does not exist.
     */
    private String getOptionalElementText(Node nodeWithOptionalElement,
	    String elementName) {

	final XPath pathsXPath = xPathFactory.newXPath();
	try {

	    final Node elementNode = (Node) pathsXPath.evaluate(elementName,
		    nodeWithOptionalElement, XPathConstants.NODE);

	    return elementNode.getTextContent().trim();

	} catch (NullPointerException npe) {
	    // The version is optional, thus ignore exceptions.
	} catch (XPathExpressionException xpee) {
	    // The version is optional, thus ignore exceptions.
	}

	return null;
    }

    /**
     * Return the text content of the mandatory element with the name specified
     * by <code>elementName</code> element of
     * <code>nodeWithMandatoryElement</code>. An exception will be throw if the
     * element is missing or if any other problems are encountered while parsing
     * the element. or <code>null</code> if it is missing.
     * 
     * @param nodeWithMandatoryElement
     *            <code>Node</code> that must contain a mandatory (child)
     *            element with the name specified by <code>elementName</code>.
     * 
     * @param elementName
     *            name of the mandatory element to parse.
     * 
     * @return a <code>String</code> instance containing the text content of the
     *         mandatory element.
     * @throws ConfigurationException
     *             if any problems are encountered while retriving the text
     *             contents of the mandatory element.
     */
    private String getMandatoryElementText(Node nodeWithMandatoryElement,
	    String elementName) throws ConfigurationException {

	final XPath pathsXPath = xPathFactory.newXPath();
	try {

	    final Node elementNode = (Node) pathsXPath.evaluate(elementName,
		    nodeWithMandatoryElement, XPathConstants.NODE);

	    return elementNode.getTextContent().trim();

	} catch (Exception exception) {
	    // This is a mandatory element, thus no exceptions are tolerated.
	    throw new ConfigurationException(String.format(
		    "Failed parsing the '%s' element in the '%s' element.",
		    elementName, nodeWithMandatoryElement.getNodeName()),
		    exception);
	}
    }

    /**
     * Return a <code>URI</code> created from the text content of the optional
     * element with the name specified by <code>elementName</code> in the
     * <code>nodeWithOptionalElement</code> or <code>null</code> if it is not
     * found.
     * 
     * @param nodeWithOptionalURIElement
     *            <code>Node</code> that may contain a (child) element with the
     *            name specified by <code>elementName</code> .
     * @param elementName
     *            name of the optional element to parse.
     * @return a <code>URI</code> instance created from the text content of the
     *         optional element or <code>null</code> if the element was not
     *         found.
     * @throws ConfigurationException
     *             if there are problems parsing and creating a the
     *             <code>URI</code> instance.
     */
    private URI getOptionalElementURI(Node nodeWithOptionalURIElement,
	    String elementName) throws ConfigurationException {

	final XPath pathsXPath = xPathFactory.newXPath();

	try {
	    final Node uriElementNode = (Node) pathsXPath.evaluate(elementName,
		    nodeWithOptionalURIElement, XPathConstants.NODE);

	    return new URI(uriElementNode.getTextContent().trim());

	} catch (XPathExpressionException xpee) {
	    // The URI element is optional, thus ignore exceptions.
	} catch (NullPointerException npe) {
	    // The URI element is optional, thus ignore exceptions.
	} catch (URISyntaxException uriSyntalException) {
	    throw new ConfigurationException(String.format(
		    "Failed parsing the '%s' element and creating a URI, in "
			    + "the '%s' element.", elementName,
		    nodeWithOptionalURIElement.getNodeName()),
		    uriSyntalException);
	}

	return null;
    }

    private Property[] getServiceProperties(Node serviceDescriptionNode)
	    throws ConfigurationException {

	Node propertyNode = null;
	try {
	    final XPath pathsXPath = xPathFactory.newXPath();
	    final NodeList propertyNodes = (NodeList) pathsXPath.evaluate(
		    ConfigurationFileTagsV1.PROPERTIES_PROPERTY_XPATH,
		    serviceDescriptionNode, XPathConstants.NODESET);

	    ArrayList<Property> properties = new ArrayList<Property>();
	    for (int propertyIdx = 0; propertyIdx < propertyNodes.getLength(); propertyIdx++) {
		propertyNode = propertyNodes.item(propertyIdx);

		final NamedNodeMap propertyAttributes = propertyNode
			.getAttributes();

		// Get the values for the mandatory attributes and sub-nodes.
		final URI propertyID = new URI(propertyAttributes.getNamedItem(
			ConfigurationFileTagsV1.ID_ATTRIBUTE).getNodeValue());
		Property.Builder propertyBuilder = new Property.Builder(
			propertyID);
		propertyBuilder.name(propertyAttributes.getNamedItem(
			ConfigurationFileTagsV1.NAME_ATTRIBUTE).getNodeValue());

		propertyBuilder = addValue(propertyBuilder, propertyNode);

		// Add values from optional attributes and sub-nodes.
		try {
		    propertyBuilder.type(propertyAttributes.getNamedItem(
			    ConfigurationFileTagsV1.TYPE_ATTRIBUTE)
			    .getNodeValue());

		    propertyBuilder.description(getDescription(propertyNode));
		} catch (Exception exception) {
		    // Ignore exceptions thrown due to missing optional
		    // attributes and sub-nodes.
		}

		properties.add(propertyBuilder.build());
	    }
	    return properties.toArray(new Property[properties.size()]);
	} catch (Exception exception) {
	    throw new ConfigurationException(String.format(
		    "Failed parsing the '%s' element of the configuration"
			    + " document.", serviceDescriptionNode
			    .getNodeName()), exception);
	}
    }

    /**
     * Add the text content of <code>&lt;value&gt;</code> in
     * <code>nodeWithValueElement</code> and the value of its optional
     * <code>&quot;unit&quot;</code> attribute to the
     * <code>propertyBuilder</code>.
     * 
     * @param propertyBuilder
     *            <code>Property.Builder</code> instance to store the retrieved
     *            data in.
     * @param nodeWithValueElement
     *            <code>Node</code> instance having a <code>&lt;value&gt;</code>
     *            sub-node.
     * @return the <code>Property.Builder</code> specified by
     *         <code>propertyBuilder</code> with the added data retrieved from
     *         <code>nodeWithValueElement</code>.
     * @throws XPathExpressionException
     *             if no <code>&lt;value&gt;</code> element is found in
     *             <code>nodeWithValueElement</code>.
     */
    private Builder addValue(Property.Builder propertyBuilder,
	    Node nodeWithValueElement) throws XPathExpressionException {
	final XPath pathsXPath = xPathFactory.newXPath();
	final Node valueNode = (Node) pathsXPath.evaluate(
		ConfigurationFileTagsV1.VALUE_ELEMENT, nodeWithValueElement,
		XPathConstants.NODE);

	propertyBuilder.value(valueNode.getTextContent().trim());

	NamedNodeMap valueAttributes = valueNode.getAttributes();
	propertyBuilder.unit(valueAttributes.getNamedItem(
		ConfigurationFileTagsV1.UNIT_ATTRIBUTE).getNodeValue());

	return propertyBuilder;
    }

    /**
     * Return the text content of the <code>&lt;description&gt;</code> element
     * of <code>nodeWithDescriptionElement</code>.
     * 
     * @param nodeWithDescriptionElement
     *            <code>Node</code> containing a
     *            <code>&lt;description&gt;</code> (child) element.
     * @return a <code>String</code> instance containing the text content of the
     *         description element.
     * @throws XPathExpressionException
     *             if no description element is found in
     *             <code>nodeWithDescriptionElement</code>.
     */
    private String getDescription(Node nodeWithDescriptionElement)
	    throws XPathExpressionException {

	final XPath pathsXPath = xPathFactory.newXPath();
	final Node descriptionNode = (Node) pathsXPath.evaluate(
		ConfigurationFileTagsV1.DESCRIPTION_ELEMENT,
		nodeWithDescriptionElement, XPathConstants.NODE);

	return descriptionNode.getTextContent().trim();
    }

    /**
     * Collect all the unique parameters (unique by name) defined for the
     * migration paths specified by <code>planetsPaths</code> and return them in
     * a list.
     * <p/>
     * <p/>
     * The same parameter is likely to be defined for multiple paths, however,
     * if the configuration file for the generic wrapper has been properly
     * written, then all occurrences should have the same meaning, thus, only
     * the first occurrence of a parameter will be collected. For the same
     * reason, the returned parameters will not have any value to avoid
     * confusion, as the default value of a parameter may differ among the
     * various migration paths.
     * 
     * @param planetsPaths
     *            An array of <code>MigrationPath</code> instances to collect
     *            parameters from.
     * @return <code>List</code> of unique parameters declared for the paths
     *         specified by <code>planetsPaths</code>. The value of all the
     *         parameters will be <code>null</code>.
     */
    private List<Parameter> getUniqueParameters(
	    eu.planets_project.services.datatypes.MigrationPath[] planetsPaths) {

	final HashMap<String, Parameter> parameterMap = new HashMap<String, Parameter>();
	for (eu.planets_project.services.datatypes.MigrationPath migrationPath : planetsPaths) {
	    for (Parameter parameter : migrationPath.getParameters()) {

		// Collect the parameter and ignore multiple occurrences.
		// Parameters having a value will have the value stripped.
		final String parameterName = parameter.getName();
		if (!parameterMap.containsKey(parameterName)) {

		    Parameter.Builder parameterBuilder = new Parameter.Builder(
			    parameterName, null);
		    parameterMap.put(parameterName, parameterBuilder.build());
		}
	    }
	}

	return new ArrayList<Parameter>(parameterMap.values());
    }

    /**
     * Extract the unique input format <code>URI</code>s from the migration
     * paths specified by <code>planetsPaths</code>.
     * 
     * @param planetsPaths
     *            A list of planets <code>MigrationPath</code> instances to
     *            extract input format <code>URI</code>s from.
     * @return An array containing the unique input format <code>URI</code>s
     *         from the migration paths.
     */
    private URI[] getInputFormats(
	    eu.planets_project.services.datatypes.MigrationPath[] planetsPaths) {
	final Set<URI> inputFormats = new HashSet<URI>();
	for (eu.planets_project.services.datatypes.MigrationPath migrationPath : planetsPaths) {
	    inputFormats.add(migrationPath.getInputFormat());
	}
	return inputFormats.toArray(new URI[inputFormats.size()]);
    }

    private eu.planets_project.services.datatypes.MigrationPath[] getPlanetsMigrationPaths(
	    Document wrapperConfiguration) throws MigrationPathConfigException {

	final DBMigrationPathFactory migrationPathFactory = new DBMigrationPathFactory(
		wrapperConfiguration);

	final MigrationPaths migrationPaths = migrationPathFactory
		.getAllMigrationPaths();

	final Collection<MigrationPath> pathCollection = migrationPaths
		.getAllMigrationPaths();

	return convertToPlanetsPaths(pathCollection)
		.toArray(
			new eu.planets_project.services.datatypes.MigrationPath[pathCollection
				.size()]);
    }

    /**
     * Initialise a <code>Tool</code> instance with the tool description
     * information found in &quot;tool&quot; element in the
     * <code>nodeWithToolDescription</code> node.
     * 
     * @param nodeWithToolDescription
     *            <code>Node</code> containing a tool description element.
     * @return A <code>Tool</code> instance created from the tool description
     *         (child) element provided by <code>nodeWithToolDescription</code>.
     * @throws ConfigurationException
     *             if any problems are encountered while parsing the tool
     *             description element.
     */
    private Tool getToolDescriptionElement(Node nodeWithToolDescription)
	    throws ConfigurationException {

	final XPath pathsXPath = xPathFactory.newXPath();
	Node toolDescriptionNode;
	try {
	    toolDescriptionNode = (Node) pathsXPath.evaluate(
		    ConfigurationFileTagsV1.TOOL_ELEMENT,
		    nodeWithToolDescription, XPathConstants.NODE);

	    // TODO: If getDescription(), getVersion() et al. are all optional
	    // wherever they may be called then put the exception handling into
	    // these methods instead!
	    String description = null;
	    try {
		description = getDescription(toolDescriptionNode);
	    } catch (NullPointerException npe) {
		// The description is optional, thus ignore exceptions.
	    } catch (XPathExpressionException xpee) {
		// The description is optional, thus ignore exceptions.
	    }

	    final String version = getVersionElement(toolDescriptionNode);

	    URI identifierURI = getOptionalElementURI(toolDescriptionNode,
		    ConfigurationFileTagsV1.IDENTIFIER_ELEMENT);

	    String name = getOptionalElementText(toolDescriptionNode,
		    ConfigurationFileTagsV1.NAME_ELEMENT);

	    URL homePageURL = null;
	    String homePage = null;
	    try {
		homePage = getHomePageElement(toolDescriptionNode);
		if (homePage != null) {
		    homePageURL = new URL(homePage);
		}
	    } catch (XPathExpressionException xpee) {
		// The home page is optional, thus ignore exceptions.
	    } catch (NullPointerException npe) {
		// The home page is optional, thus ignore exceptions.
	    } catch (MalformedURLException malformedURLException) {
		throw new ConfigurationException(String.format(
			"Invalid home page URL '%s' in element: %s", homePage,
			toolDescriptionNode.getNodeName()),
			malformedURLException);
	    }

	    final Tool toolDescription = new Tool(identifierURI, name, version,
		    description, homePageURL);
	    return toolDescription;
	} catch (XPathExpressionException xPathExpressionException) {
	    throw new ConfigurationException(String.format(
		    "Failed parsing the '%s' element in the element: %s",
		    ConfigurationFileTagsV1.TOOL_ELEMENT,
		    nodeWithToolDescription.getNodeName()),
		    xPathExpressionException);
	}
    }

    /**
     * Return the text content of the optional <code>&lt;version&gt;</code>
     * element of <code>nodeWithVersionElement</code> or <code>null</code> if it
     * is missing.
     * 
     * @param nodeWithVersionElement
     *            <code>Node</code> that may contain a
     *            <code>&lt;version&gt;</code> (child) element.
     * @return a <code>String</code> instance containing the text content of the
     *         version element or <code>null</code> if it does not exist.
     */
    private String getVersionElement(Node nodeWithVersionElement)
	    throws XPathExpressionException {

	final XPath pathsXPath = xPathFactory.newXPath();
	try {

	    final Node versionNode = (Node) pathsXPath.evaluate(
		    ConfigurationFileTagsV1.VERSION_ELEMENT,
		    nodeWithVersionElement, XPathConstants.NODE);

	    return versionNode.getTextContent().trim();

	} catch (NullPointerException npe) {
	    // The version is optional, thus ignore exceptions.
	} catch (XPathExpressionException xpee) {
	    // The version is optional, thus ignore exceptions.
	}

	return null;
    }

    /**
     * Return the text content of the <code>&lt;homepage&gt;</code> element of
     * <code>nodeWithHomePageElement</code>.
     * 
     * @param nodeWithHomePageElement
     *            <code>Node</code> containing a homepage (child) element.
     * @return a <code>String</code> instance containing the text content of the
     *         homepage element.
     * @throws XPathExpressionException
     *             if no homepage element is found in
     *             <code>nodeWithHomePageElement</code>.
     */
    private String getHomePageElement(Node nodeWithHomePageElement)
	    throws XPathExpressionException {

	final XPath pathsXPath = xPathFactory.newXPath();
	final Node homePageNode = (Node) pathsXPath.evaluate(
		ConfigurationFileTagsV1.HOME_PAGE_ELEMENT,
		nodeWithHomePageElement, XPathConstants.NODE);

	return homePageNode.getTextContent().trim();
    }

    /**
     * TODO: This should go into a utility class.
     * 
     * Convert a collection of generic wrapper migration paths to a PLANETS
     * <code>MigrationPath</code> instances. During this conversion any presets
     * of the generic wrapper migration paths will be converted to a PLANETS
     * parameters and a list of valid values and their descriptions will be
     * appended to the description of the (preset) parameter.
     * 
     * @param genericWrapperMigrationPaths
     *            A collection of generic wrapper <code>MigrationPath</code>
     *            instances to convert.
     * @return a <code>List</code> of
     *         <code>eu.planets_project.services.datatypes.MigrationPath</code>
     *         created from the generic wrapper migration paths.
     */
    private List<eu.planets_project.services.datatypes.MigrationPath> convertToPlanetsPaths(
	    Collection<MigrationPath> genericWrapperMigrationPaths) {

	final ArrayList<eu.planets_project.services.datatypes.MigrationPath> planetsPaths = new ArrayList<eu.planets_project.services.datatypes.MigrationPath>();
	for (MigrationPath migrationPath : genericWrapperMigrationPaths) {

	    final List<Parameter> planetsParameters = new ArrayList<Parameter>();
	    planetsParameters.addAll(migrationPath.getToolParameters());

	    // Add a parameter for each preset (category)
	    final ToolPresets toolPresets = migrationPath.getToolPresets();
	    final Collection<Preset> presets = toolPresets.getAllToolPresets();
	    for (Preset preset : presets) {

		// Create a parameter for each preset which is not assigned any
		// value (i.e. null), however, the default preset parameter will
		// be
		// assigned the name of the default preset setting.
		Parameter.Builder parameterBuilder;
		if (preset.getName().equals(toolPresets.getDefaultPresetID())) {
		    parameterBuilder = new Parameter.Builder(preset.getName(),
			    preset.getDefaultSetting().getName());
		} else {
		    parameterBuilder = new Parameter.Builder(preset.getName(),
			    null);
		}

		// Append a description of the valid values for the preset
		// parameter.
		String usageDescription = "\n\nValid values : Description\n";

		for (PresetSetting presetSetting : preset.getAllSettings()) {

		    usageDescription += "\n" + presetSetting.getName() + " : "
			    + presetSetting.getDescription();
		}

		parameterBuilder.description(preset.getDescription()
			+ usageDescription);

		planetsParameters.add(parameterBuilder.build());
	    }
	    planetsPaths
		    .add(new eu.planets_project.services.datatypes.MigrationPath(
			    migrationPath.getSourceFormat(), migrationPath
				    .getDestinationFormat(), planetsParameters));
	}

	return planetsPaths;
    }

}
