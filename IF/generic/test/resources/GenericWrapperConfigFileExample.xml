<serviceWrapping version="1.0">

	<!--
		General instructions: Please leave any optional fields empty if they
		are not pertinent to a wrapping. That is, do not remove the tags from
		the file - just leave them with no contents. Optional fields will be
		explicitly marked as optional.
	-->
	<serviceDescription>

		<!-- A brief name by which this service is known. -->
		<title>
			Example: Eggnog migration service.
        </title>

		<!--
			A human readable description of the service. This is your chance to
			describe your service to potential users. Although automatic service
			discovery will more likely depend upon service type, input formats
			and tool wrapped, users browsing the Planets service registry will
			see the name and description. The description may be written in HTML,
			using a <![CDATA[ <b>Hi</b> ]]> (Optional field)
		-->
		<description>
			Example description of a service wrapping of a fantastic
			command line tool for migrating an egg to eggnog.
        </description>

		<!-- Detailed description of the wrapped command line tool. -->
		<tool>

			<!-- The name of the wrapped tool (Optional field) -->
			<name>
				Example: HandMixer.exe
            </name>

			<!--
				An identifier for this tool, should be resolvable via a tool
				registry. (Optional field)
			-->
			<identifier>http://example-planets-registry.eu/toolident?4385794357
			</identifier>

			<!-- Tool description (Optional field) -->
			<description>
				Example: A useful tool for migrating eggs to eggnog.
			</description>

			<!--
				Link to the (project) home page of the command line tool. (Optional
				field)
			-->
			<homepage>http://example.org</homepage>

			<!--
				Tool version information. E.g. the version string printed by the
				tool. (Optional field)
			-->
			<version>
				HandMixer V4.13 by J. Random Hacker.
            </version>
		</tool>

		<!-- Service wrapping version information. (Optional field)-->
		<version>
			3.141592653589793
        </version>

		<!--
			Who wrote the wrapper. Preferred form would be a URI or a full email
			address(es), like: "Full Name <fullname@server.com>".
		-->
		<creator>
			<![CDATA["Easter Bunny <easter.bunny@bunny.net>"]]>
		</creator>

		<!--
			A unique identifier for this service. "We need a unique id for every
			service; Andrew Lindley is using a MD5 hash to identify a service.
			This is a brilliant idea. I would say this field summarizes Name of
			class impl service, Version of service and ID of Tool (URI) or makes
			them unnecessary.". This is an optional field, however, the generic
			wrapper will automatically generate an identifier if no value is
			specified. This is done by generating a MD5 hash of a string
			containing the canonical class name of the wrapping service
			implementation class, the service version and the toolID. (Optional
			field)
		-->
		<identifier>Example_custom_identifier</identifier>

		<!--
			Installation and setup instructions for the service. This includes
			software to be installed, environment variables to be set, properties
			to be set, etc. It is the responsibility of the developer to ensure
			that the instructions provided are of appropriate detail and quality.
			This really depends upon the tool been wrapped, for example the pure
			Java services currently in pserv don't provide any instructions but
			they should build and deploy when the pserv project is built and they
			should simply work without any set up. More complex tools relying on
			installed software will require more detailed information. As yet,
			there are no formal requirements on the instructions, but they should
			be sufficient for the build manager and the testbed manager to deploy
			the service. The instructions should closely follow the installation
			instructions from the Service Submission document. (Optional field)
		-->
		<instructions>
			Example: Please install the XYZ tool on the system to
			make this service work.
        </instructions>

		<!--
			A URI that provides a link to further information about a service
			wrapper. This could point to a web page, information about the tool
			wrapped, or a help page hosted on the web. (Optional field)
		-->
		<furtherinfo>http://example.org</furtherinfo>

		<!--
			A URI that can be used to provide a graphic image logo for the
			service. This will be displayed in the service registry if present.

			(Optional field)
		-->
		<logo>http://www.planets-project.eu/graphics/Planets_Logo.png</logo>

		<!--
			An optional list of hard-coded properties to add to the service
			description. If no properties are applicable to a wrapping then the
			properties tag should just be left empty. That is, there must be no
			"property" tags inside it. FIXME! Come up with some brilliant
			examples here..... Would OS/Hardware platform qualify? (Optional
			field)
		-->
		<properties>
			<property name="exampleName">
				exampleValue
		</property>
		</properties>

	</serviceDescription>

	<!--
		THE SELF-TEST SECTION IS CURRENTLY NOT USED and should thus be omitted
		in the current wrappings.
	-->
	<selfTests>

		<test name="tr version test">
			<command>
				sh
            </command>

			<commandparameters>
				<parameter>
					-c
                </parameter>

				<parameter>
					tr --version | md5sum
                </parameter>
			</commandparameters>

			<expectedOutput>9bac2d02bdb596a4d3297e44e5c8008 -</expectedOutput>
			<expectedExitCode>0</expectedExitCode>
		</test>
	</selfTests>

	<paths>

		<path>
			<!--
				This path is an illustration of the possibility to actually define
				multiple migration paths with only one path element, which is
				convenient in case the tool is capable of migrating from a number of
				formats to one specific format. However, the generic wrapper is
				unable to automatically validating that the all these migrations can
				be performed with the same command line (except from different
				parameters specified by the caller). Thus, it is the responsibility
				of the person writing the configuration file, to verify that it is
				possible.
			-->

			<!--
				Example of migration from various revisions of the PS format to the
				pdf1.2 format (Acrobat 3-and-later)
			-->

			<inputformats>
				<!--
					List of format URIs identifying the valid input formats for the
					wrapped command(s) in this "path" section. It is recommended to use
					PRONOM URIs where possible in order to achieve the most accurate
					description of the formats. File suffixes are inaccurate as most
					file formats are available in several revisions. However, if a
					format is unknown to PRONOM (or whatever registry that is being
					used) and thus it is necessary to "invent" a format URI, then it
					should be on the form: "info:planets/fmt/ext/<PUT FORMAT DESCRIPTOR
					HERE>"
				-->

				<uri value="info:pronom/x-fmt/91" />
				<uri value="info:pronom/x-fmt/406" />
				<uri value="info:pronom/x-fmt/407" />
				<uri value="info:pronom/x-fmt/408" />
			</inputformats>

			<outputformat>
				<!--
					Format URI identifying the output format of the wrapped command(s)
					in this "path" section. It is recommended to use a PRONOM URI when
					possible in order to achieve the most accurate description of the
					format. File suffixes are inaccurate as most file formats are
					available in several revisions. However, if a format is unknown to
					PRONOM (or whatever registry that is being used) and thus it is
					necessary to "invent" a format URI, then it should be on the form:
					"info:planets/fmt/ext/<PUT FORMAT DESCRIPTOR HERE>"
				-->

				<uri value="info:pronom/fmt/16" />
			</outputformat>

			<commandline>
				<!--
					This element contains all the fragments that constitute the command
					line to be executed by the generic wrapper. The general form of a
					command line is "<shell command> <shell option1> <shell option 2>
					... <shell option N>". Thus, a wrapped tool is actually executed in
					a separate shell. It is important that only one parameter is
					specified by each parameter section. That is, if you want to
					execute something like: "/bin/sh -c -e -f migrationTool toolParam1
					toolParam2" then "-c", "-e" and "-f" must be specified by each
					their parameter section, while the entire string "migrationTool
					toolParam1 toolParam2" may be specified in the same parameter
					section. Anything in the command and parameter text can be replaced
					by a label of the form "#label" to be substituted by some value at
					runtime by the generic wrapper. The value which the label is
					replaced with may be specified by the caller of the service as a
					parameter, however, in that case the label must be declared in the
					"toolparameters" section. The generic wrapper will attempt to fetch
					values for undeclared labels from the system/runtime configuration,
					which is useful e.g. for specifying the location of the migration
					tool at installation time of the system. However, please make sure
					that the labels are unique within each path section.
				-->

				<command>
					<!--
						The command to be executed by the generic wrapper. Typically this
						will be "sh" on unix/linux systems and "command.exe" on Windows
						systems. However, do not rely on the command to exist in the
						system search path and do not specify an absolute path in this
						configuration file as this may (will!) break on various systems.
						Instead the command should be replaced by a label of the form
						"#label", just like in this example. The only requirement to the
						label name written in this element is that the absolute path to
						the program must be given in the dynamic/system configuration of
						the service. I.e. "shellcommand" should be mapped to something
						like "/bin/sh". As opposed to labels to be substituted with
						parameter values, this label must remain undefined in this path
						configuration, thus, forcing the generic wrapper to obtain the
						appropriate value from the system/runtime configuration.
					-->

					#shellcommand
				</command>

				<commandparameters>
					<!-- An unbounded list of parameters to the above command. -->

					<parameter>
						<!--
							On unix/linux systems the sh command needs the option -c to
							realise that is should execute a command rather than starting a
							new shell and on Windows systems the cmd.exe needs the /c option
							for the same. In order to make this configurable, a label should
							be put in place of the option so the generic wrapper can
							substitute it with the appropriate value. However, this label
							must remain undefined within this path configuration, just like
							the shell command label, to make the generic wrapper obtain the
							appropriate value from the dynamic system configuration. This
							makes it possible to make a wrapped tool work on different
							platforms by changing the system/runtime configuration.
						-->

						#shellcommandoption
					</parameter>

					<parameter>
						<!--
							This is the actual shell command line to be wrapped, however,
							notice that there is no actual tool command in this example. It
							has been replaced by a label, just like the shell command, as the
							same rule applies: The actual migration tool command must not be
							specified directly in this configuration file as the generic
							wrapper will get the tool command from the system/runtime
							configuration. Thus, "#absolutetoolpath" will be substituted with
							something like "/usr/bin/ps2pdf12" at runtime. All tags like
							"#param1" are also substituted by command parameters and
							temporary file names by the generic wrapper. However, these tag
							names (in this case "param1", "tempSource" and "tempDestination")
							must be defined elsewhere in the path description. In this
							example "param1" is defined in the "toolparameters" section,
							indicating that it is a parameter value provided by the caller of
							the service, and the remaining tags, "tempSource" and
							"tempDestination", are defined in the "toolinput" and
							"tooloutput" sections. Any intermediate temporary files must be
							defined in the "temmpfiles" section (look elsewhere in this
							example file for an example on this).
						-->

						#absolutetoolpath #param1 #tempSource #tempDestination
					</parameter>
				</commandparameters>
			</commandline>

			<toolinput>
				<!--
					This section describes how the input file is passed on to the
					command line tool. There are two options either piping the data
					through standard input to the tool or to write the data to a
					temporary file which the tool then reads it from. If the wrapped
					tool is capable of reading the input object from standard input,
					then the tag <piped/> can be specified instead of the "tempfile"
					element used in this example. However, make sure that the command
					line is correctly configured to instruct the tool to read from
					standard input and make sure that the tool actually supports it.
				-->

				<tempfile label="tempSource">
					<!--
						Get the object to migrate from a temporary file automatically
						named by the wrapper. If the tool requires a specific name for the
						input file then it can be specified by adding a name attribute
						like this: name="requiredName.foo". Please note that the label (in
						this case "tempSource") must match the label used in the command
						line where the input file must be specified.
					-->
				</tempfile>
			</toolinput>

			<tooloutput>
				<!--
					This section describes how the output object is passed on from the
					command line tool to the generic wrapper. There are two options
					either piping the data through standard output or to write the data
					to a temporary file which the generic wrapper then reads it from.
					If the wrapped tool is capable of writing the output object to
					standard output, then the tag <piped/> can be specified instead of
					the "tempfile" element used in this example. However, make sure
					that the command line is correctly configured to instruct the tool
					to write to standard output and make sure that the tool actually
					supports it.
				-->
				<tempfile label="tempDestination">
					<!--
						Write the output to a temporary file automatically named by the
						wrapper. If the tool requires a specific name for the output file
						then it can be specified by adding a name attribute like this:
						name="requiredName.foo". Please note that the label (in this case
						"tempDestination") must match the label used in the command line
						where the output file must be specified.
					-->
				</tempfile>
			</tooloutput>

			<tempfiles>
				<!--
					More complex tool wrappings may utilise intermediate temporary
					files. Please find examples on this elsewhere in this example file.
					The use of temporary intermediate files is optional, however, this
					section must be present although empty if no intermediate temporary
					files are applied.
				-->
			</tempfiles>

			<toolparameters>
				<!--
					This is an unbounded list describing all the parameters that the
					caller of the wrapped tool service can specify. All the parameter
					labels used in the command line to specify parameters, which must
					be provided by the caller of the service, must be declared here. If
					no "caller" parameter labels are used in the "commandline" section,
					then this section must still be present although empty.
				-->
				<parameter name="param1">
					<!--
						Instruct the generic wrapper to accept a parameter called "param1"
						and provide a description that it can pass on to users, to
						instruct them in how to use it. That is, information about valid
						parameter values and their effect. (the below example is quite
						unsatisfactory)
					-->
					<description>Command line parameters for the 'ps2pdf'
						command.
						See
						'man gs'.
                    </description>
				</parameter>
			</toolparameters>

			<toolpresets default="mode">
				<!--
					An unbounded list of presets. A wrapped tool can optionally provide
					a number of presets to make it easier for the users to use it. A
					preset will appear to be just another parameter to the caller
					although making use of a preset actually will add/override a number
					of parameters. In this case the wrapping uses only one parameter,
					however, a preset could easily provide values for more parameters.
					Please note that the "toolpresets" section must be empty if no
					presets are defined and no "default" attribute may be specified!
				-->
				<preset name="mode" default="Normal">
					<!--
						If the caller of the service do not specify any value for neither
						the tool parameters nor the "mode" parameter, which this preset
						will be mapped to, then the generic wrapper will automatically
						assign "Normal" to the "mode" parameter, causing this preset to be
						applied. The below description is information to the callers about
						the over-all effect of applying values from this preset.
					-->
					<description>
						Takes the options Normal or Silent.
						Defaults to
						'normal'.
                    </description>

					<settings name="Silent">
						<!--
							If the "mode" preset (i.e. parameter) is set to "Silent" then
							param1 will be set to the below value, provided that the caller
							has not already specified a value for param1. The description
							should give a meaningful description about the effect of choosing
							this preset value.
						-->
						<parameter name="param1"><![CDATA['-q']]>
						</parameter>
						<description>Silent Running</description>
					</settings>

					<settings name="Normal">
						<!--
							If the "mode" preset (i.e. parameter) is set to "Normmal" then
							param1 will be set to the below value (an empty string), provided
							that the caller has not already specified a value for param1. The
							description should give a meaningful description about the effect
							of choosing this preset value.
						-->
						<parameter name="param1"><![CDATA[]]>
						</parameter>
						<description>Normal</description>
					</settings>

				</preset>
			</toolpresets>

		</path>

		<path>
			<!--
				Silly migration path for conversion of lower case text to upper case
				text, using 'cat' and 'tr', for demonstration of the usage of
				temporary source and destination files. The migration paths
				described by a combination of one of the input formats and the
				output format will overwrite any similar definitions from any
				earlier path definitions, that is, definitions closer to the top of
				the configuration file.
			-->
			<inputformats>
				<!--
					List of format URIs identifying the valid input formats for the
					wrapped command(s) in this "path" section. It is recommended to use
					PRONOM URIs where possible in order to achieve the most accurate
					description of the formats. File suffixes are inaccurate as most
					file formats are available in several revisions. However, if a
					format is unknown to PRONOM (or whatever registry that is being
					used) and thus it is necessary to "invent" a format URI, then it
					should be on the form: "info:planets/fmt/ext/<PUT FORMAT DESCRIPTOR
					HERE>"
				-->

				<uri value="info:planets/fmt/ext/lowercase" />
			</inputformats>

			<outputformat>
				<!--
					Format URI identifying the output format of the wrapped command(s)
					in this "path" section. It is recommended to use a PRONOM URI when
					possible in order to achieve the most accurate description of the
					format. File suffixes are inaccurate as most file formats are
					available in several revisions. However, if a format is unknown to
					PRONOM (or whatever registry that is being used) and thus it is
					necessary to "invent" a format URI, then it should be on the form:
					"info:planets/fmt/ext/<PUT FORMAT DESCRIPTOR HERE>"
				-->

				<uri value="info:planets/fmt/ext/uppercase" />
			</outputformat>

			<commandline>
				<!--
					This element contains all the fragments that constitute the command
					line to be executed by the generic wrapper.
				-->

				<command>
					<!--
						The command to be executed by the generic wrapper. Typically this
						will be "sh" on unix/linux systems and "command.exe" on Windows
						systems. The only requirement to the name written in this element
						is that the absolute path to the program must be given in the
						dynamic/system configuration of the service. E.g. "sh" should be
						mapped to something like "/bin/sh".
					-->

					/bin/sh
				</command>

				<commandparameters>
					<!-- An un bounded list of parameters to the above command. -->

					<parameter>
						<!--
							sh needs the option -c to realise that is should execute a
							command rather than starting a new shell.
						-->

						-c
					</parameter>

					<!--
						This is the exact shell command line to be wrapped, except from
						that all tags like "#some_label" are substituted by command
						parameters and temporary file names. The tag name (in this case
						"some_label") must be defined in the "toolparameters" section. The
						same goes for temporary files. In the below example there are
						three temporary file tags, tempSource, myInterimFile and
						tempDestination.
					-->

					<parameter>
                        <![CDATA[cat #param1 #tempSource > #myInterimFile && tr #param2 #myInterimFile > #tempDestination]]>
					</parameter>
				</commandparameters>
			</commandline>


			<!--
				FIXME! in/output "files" probably should have their own sections
			-->

			<toolinput>

				<!-- Input enten fra stdin eller temp. fil. <stdin /> -->
				<!--
					This definition is used for the file containing the data to be
					migrated, that is, the data provided by the caller. If it is not
					defined the the tool wrapper expects that the tool reads its data
					from standard input and it will therefore pipe the data to be
					migrated through there.
				-->
				<tempfile label="tempSource" name="desiredInputFileName">
					<!--
						Get the object to migrate from a temporary file with a specific
						name. The name attribute is only necessary if the tool requires a
						specific name for the input file.
					-->
				</tempfile>
			</toolinput>

			<tooloutput>
				<!--
					Kanalisere enten stdout eller temp. fil over i et Content objekt.
				-->
				<!--
					This definition is used for the file containing the final migrated
					output, that is, the data the tool wrapper should pick up and
					return to the caller of the service. If it is not defined the the
					tool wrapper expects that the tool sends the migrated data to
					standard output, which then will be picked up and returned to the
					caller.
				-->
				<tempfile label="tempDestination">
					<!--
						Return the output to a temporary file automatically named by the
						wrapper. If a specific name is needed for the output file then the
						"name" attribute must be specified as well.
					-->
				</tempfile>
			</tooloutput>

			<tempfiles>
				<!--
					Any temporary files used in the command line must be defined in
					this section, that is, the contents of the label attributes of the
					entries must match the names used between the % signs in the
					command line. The use of temporary files is optional and depends
					entirely on the contents of the command line. Further more, a temp.
					file entry may also specify a name for the temporary file to be
					generated, if necessary. This is useful for tools that insist on
					having a given suffix on its input/output files.
				-->
				<tempfile label="myInterimFile" name="myDesiredTempFileName.foo">
					<!--
						tempfile entries are used for intermediate temporary files which
						may be necessary to create if the wrapped command line contains
						chained commands. Multiple tempfile entries are allowed, however,
						each should have a unique name and it must match the names used in
						the command line.
					-->
				</tempfile>
			</tempfiles>

			<!--
				The tool will terminate with an error if not all tool parameters are
				defined at invocation. Any specified parameters will overwrite the
				corresponding parameters from any specified tool preset. That is, if
				the caller of the tool specifies e.g. mode=complete and param1=-n,
				then the tool will be invoked with param1=-n and param2=[:lower:]'
				'[:upper:] which will have the same effect as just specifying
				mode=extra. Given the definitions of this example file.
			-->

			<toolparameters>
				<!--
					All these parameters must be specified by the caller if no preset
					is specified. The occurrences of the parameter names in the above
					command line will be substituted with the value assigned to them by
					the caller.
				-->
				<parameter name="param1">
					<description><![CDATA[Command line parameters for the 'cat' command. See 'man cat'.]]>
					</description>
				</parameter>
				<parameter name="param2">
					<!-- Demonstration of CDATA usage in descriptions. -->
					<description><![CDATA[Command line parameters for the 'tr' command. See 'man tr'.]]>
					</description>
				</parameter>
			</toolparameters>

			<!--
				Tool presets can be used instead of messing with the command line
				parameters. However, these presets can also be used as default
				settings which will make it possible only to specify a some of the
				parameters for the tool, as unspecified parameters just can be taken
				from the defaults.
			-->
			<toolpresets default="mode">
				<!--
					This section defines all possible preset categories for the tool.
					The caller may use only one of the preset categories when calling,
					e.g. specifying both mode=AC-DC and quality=good would result in an
					error. If no parameters or preset is specified by the caller, then
					the default "mode" preset category and its default "complete" value
					is automatically chosen in this example.
				-->
				<preset name="mode" default="complete">
					<settings name="complete">
						<parameter name="param1"><![CDATA[]]>
						</parameter>
						<parameter name="param2"><![CDATA['[:lower:]' '[:upper:]']]>
						</parameter>
						<description>Uppercase all text.</description>
					</settings>
					<settings name="AC-DC">
						<parameter name="param1"><![CDATA[]]>
						</parameter>
						<parameter name="param2"><![CDATA['A,D' 'D,A']]></parameter>
						<description>Change AC-DC to DC-AC</description>
					</settings>
					<settings name="extra">
						<parameter name="param1"><![CDATA[-n]]></parameter>
						<parameter name="param2"><![CDATA['[:lower:]' '[:upper:]']]>
						</parameter>
						<description>Uppercase all text and add line
							numbers.
                    </description>
					</settings>
					<description>Mode presets for the test tool.
                    </description>
				</preset>

				<!--
					This "quality" preset category is essentially the same as the
					"mode" category, and is only included to demonstrate that it is
					possible for the caller to have more preset categories to choose
					from.
				-->
				<preset name="quality" default="good">
					<settings name="good">
						<parameter name="param1"><![CDATA[]]>
						</parameter>
						<parameter name="param2"><![CDATA['[:lower:]' '[:upper:]']]>
						</parameter>
						<description>Uppercase all.</description>
					</settings>
					<settings name="better">
						<parameter name="param1"><![CDATA[]]>
						</parameter>
						<parameter name="param2"><![CDATA['A,D' 'D,A']]></parameter>
						<description>AC-DC to DC-AC</description>
					</settings>
					<settings name="best">
						<parameter name="param1"><![CDATA[-n]]></parameter>
						<parameter name="param2"><![CDATA['[:lower:]' '[:upper:]']]>
						</parameter>
						<description>Uppercase all and add line
							numbers.
                    </description>
					</settings>
					<description>Quality presets for the test tool.
                    </description>
				</preset>
			</toolpresets>
		</path>

		<path>

			<inputformats>
				<!--
					List of format URIs identifying the valid input formats for the
					wrapped command(s) in this "path" section. It is recommended to use
					PRONOM URIs where possible in order to achieve the most accurate
					description of the formats. File suffixes are inaccurate as most
					file formats are available in several revisions. However, if a
					format is unknown to PRONOM (or whatever registry that is being
					used) and thus it is necessary to "invent" a format URI, then it
					should be on the form: "info:planets/fmt/ext/<PUT FORMAT DESCRIPTOR
					HERE>"
				-->

				<uri value="info:planets/fmt/ext/foo" />
			</inputformats>

			<outputformat>

				<!--
					Format URI identifying the output format of the wrapped command(s)
					in this "path" section. It is recommended to use a PRONOM URI when
					possible in order to achieve the most accurate description of the
					format. File suffixes are inaccurate as most file formats are
					available in several revisions. However, if a format is unknown to
					PRONOM (or whatever registry that is being used) and thus it is
					necessary to "invent" a format URI, then it should be on the form:
					"info:planets/fmt/ext/<PUT FORMAT DESCRIPTOR HERE>"
				-->

				<uri value="planets/fmt/ext/bar" />
			</outputformat>

			<commandline>
				<command>
					<!--
						The command to be executed by the generic wrapper. Typically this
						will be "sh" on unix/linux systems and "command.exe" on Windows
						systems. The only requirement to the name written in this element
						is that the absolute path to the program must be given in the
						dynamic/system configuration of the service. E.g. "sh" should be
						mapped to something like "/bin/sh".
					-->
					sh
				</command>
				<commandparameters>
					<!-- An un bounded list of parameters to the above command. -->

					<parameter>
						<!--
							sh needs the option -c to realise that is should execute a
							command rather than starting a new shell.
						-->

						-c
					</parameter>

					<parameter>
                        <![CDATA[cat #param1 - | tr #param2 > #tempDestination]]>
					</parameter>
				</commandparameters>
			</commandline>

			<toolinput>

				<piped />
				<!--
					This definition is used for the file containing the data to be
					migrated, that is, the data provided by the caller. If it is not
					defined the the tool wrapper expects that the tool reads its data
					from standard input and it will therefore pipe the data to be
					migrated through there.
				-->
			</toolinput>

			<tooloutput>
				<!--
					Kanalisere enten stdout eller temp. fil over i et Content objekt.
				-->
				<!--
					This definition is used for the file containing the final migrated
					output, that is, the data the tool wrapper should pick up and
					return to the caller of the service. If it is not defined the the
					tool wrapper expects that the tool sends the migrated data to
					standard output, which then will be picked up and returned to the
					caller.
				-->
				<tempfile label="tempDestination">
					<!--
						Return the output to a temporary file automatically named by the
						wrapper. If a specific name is needed for the output file then the
						"name" attribute must be specified as well.
					-->
				</tempfile>
			</tooloutput>

			<toolparameters>
				<parameter name="param1">
					<description>Command line parameters for the 'cat'
						command.
						See
						'man
						cat'.
                </description>
				</parameter>
				<parameter name="param2">
					<description>Command line parameters for the 'tr'
						command.
						See
						'man
						tr'.
                </description>
				</parameter>
			</toolparameters>

			<!-- No presets -->
		</path>
	</paths>
</serviceWrapping>