/**
 * 
 */
package eu.planets_project.tb.impl.model.exec;

import java.io.Serializable;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.Calendar;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Vector;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Transient;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import eu.planets_project.services.datatypes.Parameter;
import eu.planets_project.services.datatypes.ServiceDescription;
import eu.planets_project.services.datatypes.Tool;
import eu.planets_project.tb.api.model.Experiment;
import eu.planets_project.tb.api.persistency.ExperimentPersistencyRemote;
import eu.planets_project.tb.api.persistency.ServiceRecordPersistencyRemote;
import eu.planets_project.tb.impl.model.ExperimentExecutableImpl;
import eu.planets_project.tb.impl.model.measure.MeasurementEventImpl;
import eu.planets_project.tb.impl.model.measure.MeasurementImpl;
import eu.planets_project.tb.impl.persistency.ExperimentPersistencyImpl;
import eu.planets_project.tb.impl.persistency.ServiceRecordPersistencyImpl;

/**
 * This is a record of the invocation of a service. 
 * 
 * Can be re-used outside a workflow context if required.
 * 
 * The output results can be
 *  - Lists of properties,
 *  - ServiceReport
 *  - Other outputs, depending on the action?
 * but in the TB, these can be stored as 'measurements' of different types.
 * 
 * This is just because not everything can be modelled ahead of time, and not everything is fixed.
 * e.g. the ServiceReport object may change, so we should not really depend on it, so instead, we can 
 * decompose it into the important parts, the success/fail, etc
 * 
 * 
 * For a 'user' agent, the 'parameters' could specify the view platform.
 * 
 * @author <a href="mailto:Andrew.Jackson@bl.uk">Andy Jackson</a>
 *
 */
@Entity
@XmlRootElement(name = "InvocationRecord")
@XmlAccessorType(XmlAccessType.FIELD)
public class InvocationRecordImpl implements Serializable {
    /** */
    private static final Log log = LogFactory.getLog(InvocationRecordImpl.class);
    /** */
    private static final long serialVersionUID = -8012213064019484451L;
    
    @Id
    @GeneratedValue
    @XmlTransient
    private long id = -1;
    
    /** The parent Execution entity, set if this was generated by a workflow. */
    @ManyToOne
    private ExecutionRecordImpl execution;

    /** The record of the service description of the Agent, if it is a Service */
    @ManyToOne
    private ServiceRecordImpl serviceRecord;
    
    /** The input parameters */
    @OneToMany(cascade=CascadeType.ALL, mappedBy="invocation", fetch=FetchType.EAGER)
    private Set<InvocationParameterImpl> parameters = new HashSet<InvocationParameterImpl>();
    
    /** The input digital object(s) */
    @ManyToOne(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    private Set<DigitalObjectRecordImpl> inputs = new HashSet<DigitalObjectRecordImpl>();
    
    /** Did the service complete successfully. i.e. produced an {Action}Result and ServiceReport. */
    private boolean invocationSucceeded;
    
    /** What was the service exit status - did it return a result or fail. Not necessarily
     * the same as eu.planets_project.services.datatypes.ServiceReport.Status as the service may return a malformed result. */
    public static enum ExitState {
        /** Execution succeeded, close to Status.SUCCESS */
        SUCCEEDED,
        /** Execution succeeded, but with warnings. */
        WARNING,
        /** Execution failed, with Status.TOOL_ERROR */
        TOOL_ERROR,
        /** Execution failed, with Status.INSTALLATION_ERROR */
        INSTALLATION_ERROR,
        /** Executed, but result was malformed or inconsistent. */
        MALFORMED_RESULT
    }
    private ExitState serviceStatus;
    
    /** A simple log of the output from the service. Build from the info/warn/error strings in the ServiceReport */
    private Vector<String> serviceLog = new Vector<String>();
    
    /** The output digital object(s): */
    @ManyToOne(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    private Set<DigitalObjectRecordImpl> outputs = new HashSet<DigitalObjectRecordImpl>();
    
    /** Was the service response correct, or did it fail when it should have succeeded, 
     * or indeed 'succeed' when is should have failed. Needs human or external standard test to evaluate. 
     * FIXME Perhaps this should be a 'Measurement'?
     * */
    private boolean serviceRepondedCorrectly;
    
    /** The measurements about this invocation */
    @OneToOne(cascade=CascadeType.ALL, mappedBy="invocation", fetch=FetchType.EAGER)
    private Set<MeasurementEventImpl> measurementEvents = new HashSet<MeasurementEventImpl>();
    
    /* -------------------------------------------- */
    
    /** For JAXB */
    @SuppressWarnings("unused")
    private InvocationRecordImpl() {
    }
    
    /**
     * Every InvocationRecord must have a related ServiceRecord.
     * A InvocationRecord *may* have a ExecutionRecordImpl, if invoked from a experimental workflow.
     * 
     * FIXME But what if this is a set of measurements from a human agent?
     * 
     * @param serviceRecord of the service this in an invocation of.
     */
    public InvocationRecordImpl( ServiceRecordImpl serviceRecord ) {
        this.serviceRecord = serviceRecord;
    }
    

    /**
     * @return the id
     */
    public long getId() {
        return id;
    }

    /**
     * @param id the id to set
     */
    public void setId(long id) {
        this.id = id;
    }

    /**
     * @return the execution
     */
    public ExecutionRecordImpl getExecution() {
        return execution;
    }

    /**
     * @param execution the execution to set
     */
    public void setExecution(ExecutionRecordImpl execution) {
        this.execution = execution;
    }

    /**
     * @return the parameters
     */
    public Set<InvocationParameterImpl> getParameters() {
        return parameters;
    }

    /**
     * @param p
     */
    public void addParameter( Parameter p ) {
        InvocationParameterImpl ip = new InvocationParameterImpl(p);
        ip.setInvocation(this);
        this.parameters.add(ip);
    }

    /**
     * @return the measurements
     */
    public void addMeasurementEvent( MeasurementEventImpl me ) {
        this.measurementEvents.add(me);
        me.setInvocation(this);
        return;
    }

    /**
     * @return
     */
    public Set<MeasurementEventImpl> getMeasurementEvents() {
        return this.measurementEvents;
    }

}
