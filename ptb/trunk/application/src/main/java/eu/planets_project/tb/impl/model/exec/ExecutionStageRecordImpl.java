/**
 * 
 */
package eu.planets_project.tb.impl.model.exec;

import java.io.Serializable;
import java.net.URI;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Vector;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Lob;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import eu.planets_project.services.datatypes.Parameter;
import eu.planets_project.tb.gui.backing.ExperimentBean;
import eu.planets_project.tb.gui.backing.exp.ExpTypeBackingBean;
import eu.planets_project.tb.gui.util.JSFUtil;
import eu.planets_project.tb.impl.model.eval.mockup.TecRegMockup;
import eu.planets_project.tb.impl.model.measure.MeasurementEventImpl;
import eu.planets_project.tb.impl.model.measure.MeasurementImpl;
import eu.planets_project.tb.impl.persistency.ExperimentPersistencyImpl;

/**
 * This is a record of the invocation of a service. 
 * 
 * Can be re-used outside a workflow context if required.
 * 
 * The output results can be
 *  - Lists of properties,
 *  - ServiceReport
 *  - Other outputs, depending on the action?
 * but in the TB, these can be stored as 'measurements' of different types.
 * 
 * This is just because not everything can be modelled ahead of time, and not everything is fixed.
 * e.g. the ServiceReport object may change, so we should not really depend on it, so instead, we can 
 * decompose it into the important parts, the success/fail, etc
 * 
 * 
 * For a 'user' agent, the 'parameters' could specify the view platform.
 * 
 * @author <a href="mailto:Andrew.Jackson@bl.uk">Andy Jackson</a>
 *
 */
@Entity
@XmlRootElement(name = "ExecutionStage")
@XmlAccessorType(XmlAccessType.FIELD) 
public class ExecutionStageRecordImpl implements Serializable {
    /** */
    private static final Log log = LogFactory.getLog(ExecutionStageRecordImpl.class);
    /** */
    private static final long serialVersionUID = 5405314146855620431L;

    @Id
    @GeneratedValue
    @XmlTransient
    private long id;
    
    /** The parent Execution entity, set if this was generated by a workflow. */
    @ManyToOne
    @XmlTransient
    private ExecutionRecordImpl execution;
    
    /** The name of this stage: */
    private String stage;
    
    // The set of measured properties.
    @Lob
    @Column(columnDefinition=ExperimentPersistencyImpl.BLOB_TYPE)
    private Vector<MeasurementImpl> measurements = new Vector<MeasurementImpl>();

    // TODO Manual measurements should actually be done as MeasurementEvents (below)
    @Lob
    @Column(columnDefinition=ExperimentPersistencyImpl.BLOB_TYPE)
    private Vector<MeasurementImpl> manualMeasurements = new Vector<MeasurementImpl>();
    
    /** The endpoint invoked during this stage */
    @Lob
    private URL endpoint;

    /** The record of the service description at this time */
    @ManyToOne(cascade=CascadeType.ALL)
    protected ServiceRecordImpl serviceRecord;
    
    /* ----------------- New fields ahoy, as of 20th Jan 2010 - ANJ ----------------------------*/
    
    /** The input parameters */
    @OneToMany(cascade=CascadeType.ALL, mappedBy="invocation", fetch=FetchType.EAGER)
    private Set<InvocationParameterImpl> parameters = new HashSet<InvocationParameterImpl>();
    
    /** The input digital object(s), as Data Registry URIs stored as Strings */
    @Lob
    @Column(columnDefinition=ExperimentPersistencyImpl.BLOB_TYPE)
    private Vector<String> inputs = new Vector<String>();
    
    /** Did the service complete successfully. i.e. produced an {Action}Result and ServiceReport. */
    private boolean invocationSucceeded;
    
    /** What was the service exit status - did it return a result or fail. Not necessarily
     * the same as eu.planets_project.services.datatypes.ServiceReport.Status as the service may return a malformed result. */
    public static enum ExitState {
        /** Execution succeeded, close to Status.SUCCESS */
        SUCCEEDED,
        /** Execution succeeded, but with warnings. */
        WARNING,
        /** Execution failed, with Status.TOOL_ERROR */
        TOOL_ERROR,
        /** Execution failed, with Status.INSTALLATION_ERROR */
        INSTALLATION_ERROR,
        /** Executed, but result was malformed or inconsistent. */
        MALFORMED_RESULT
    }
    private ExitState serviceStatus;
    
    /** A simple log of the output from the service. Build from the info/warn/error strings in the ServiceReport.
     * Should follow a standard format:
     *   INFO: Message.
     *   WARN: Warning.
     *   ERROR: Reason.
      */
    @Lob
    @Column(columnDefinition=ExperimentPersistencyImpl.BLOB_TYPE)
    private Vector<String> serviceLog = new Vector<String>();
    
    /* FIXME Add other output types? Like the WorkflowResult? Prob not necessary at per-invocation level right now. */
    
    /** The output digital object(s), as DR URIs, stored as strings: */
    //@ManyToOne(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @Lob
    @Column(columnDefinition=ExperimentPersistencyImpl.BLOB_TYPE)
    private Vector<String> outputs = new Vector<String>();
    
    /** The measurements about this invocation */
    @OneToMany(cascade=CascadeType.ALL, mappedBy="targetInvocation", fetch=FetchType.EAGER)
    private Set<MeasurementEventImpl> measurementEvents = new HashSet<MeasurementEventImpl>();    
    
    /* ----------------------- Constructors ---------------------*/
    
    /** for JAXB */
    @SuppressWarnings("unused")
    private ExecutionStageRecordImpl() {
    }
    /**
     * @param stagePreMigrate
     */
    public ExecutionStageRecordImpl(ExecutionRecordImpl execution, String stageName) {
        this.execution = execution;
        this.stage = stageName;
    }

    /**
     * @return the id
     */
    public long getId() {
        return id;
    }

    /**
     * @param id the id to set
     */
    public void setId(long id) {
        this.id = id;
    }

    /**
     * @return the stage
     */
    public String getStage() {
        return stage;
    }

    /**
     * @param stage the stage to set
     */
    public void setStage(String stage) {
        this.stage = stage;
    }

    /**
     * @return the endpoint
     */
    public URL getEndpoint() {
        return endpoint;
    }

    /**
     * @param endpoint the endpoint to set
     */
    public void setEndpoint(URL endpoint) {
        this.endpoint = endpoint;
    }

    /**
     * @return the serviceRecord
     */
    public ServiceRecordImpl getServiceRecord() {
        return serviceRecord;
    }

    /**
     * @param serviceRecord the serviceRecord to set
     */
    public void setServiceRecord(ServiceRecordImpl serviceRecord) {
        if( serviceRecord != null) {
            log.info("Setting service record: name = "+ serviceRecord.getServiceName());
        }
        this.serviceRecord = serviceRecord;
    }

    /**
     * @return the service backed measurements
     */
    public List<MeasurementImpl> getMeasurements() {
        return measurements;
    }
    

    /**
     * @return the manual measurements
     */
    public List<MeasurementImpl> getManualMeasurements() {
        return this.manualMeasurements;
    }
    
    /**
     * FIXME this shouldn't be in the ExecutionStageRecord but rather in the ETypeBean - getObservables is mixing up concepts??
     * A helper either fetching the service backed measured observables or the manually measured ones
     * @param measuredObsManually true: manually ones false: automatically measured ones
     * @return
     */
    public List<MeasurementImpl> getMeasuredObservablesHelper(boolean measuredObsManually) {
    	
    	// Get the actual measurements:
        ExperimentBean expBean = (ExperimentBean)JSFUtil.getManagedObject("ExperimentBean");
        List<MeasurementImpl> mrl;
        HashMap<String, List<MeasurementImpl>> observables;
        
        // Look up the observables and their definitions:
        ExpTypeBackingBean exptype = ExpTypeBackingBean.getExpTypeBean(expBean.getEtype());
      
        //decide which measurements to fetch
        if( measuredObsManually){
        	mrl = this.getManualMeasurements();
        	observables = exptype.getManualObservables();
        }else{
        	mrl = this.getMeasurements();
        	observables = exptype.getObservables();
        }
        
        // Patch the descriptions in with the results:
        List<MeasurementImpl> mobs = new ArrayList<MeasurementImpl>();
        for( MeasurementImpl mr : mrl ) {
            MeasurementImpl new_m = null;
            
            // Look for matches:
            if( observables.keySet().contains( this.getStage() )) {
                for( MeasurementImpl m : observables.get( this.getStage() ) ) {
                    //log.info("Comparing '"+m.getIdentifier() +"' to '"+mr.getIdentifier()+"', "+m.getName());
                    if( m.getIdentifier() != null && mr.getIdentifier() != null &&
                            m.getIdentifier().toString().equals( mr.getIdentifier() ) ) {
                        new_m = m.clone();
                        new_m.setValue( mr.getValue() );
                    }
                }
            }
            
            // If that doesn't work, generate manually:
            if( new_m == null && mr.getIdentifier() != null ) {
                new_m = new MeasurementImpl(null,mr);
            }
            
            // Add to the results:
            if( new_m != null ) {
                //log.info("Adding observable: "+new_m.toString());
                mobs.add(new_m);
            }
        }

        return mobs;
    }
    
    /**
     * Gets the manual Measurements and patches in the property data, if available.
     * @return Looks up the measurments, patching in the definitions of the properties.
     */
    public List<MeasurementImpl> getMeasuredManualObservables() {
    	return getMeasuredObservablesHelper(true);
    }

    /**
     * Gets the service backed Measurements and patches in the property data, if available.
     * @return Looks up the measurments, patching in the definitions of the properties.
     */
    public List<MeasurementImpl> getMeasuredObservables() {
    	return getMeasuredObservablesHelper(false);
    }

    /**
     * @param measurements the service backed measurements to set
     */
    public void setMeasurements(List<MeasurementImpl> measurements) {
        this.measurements = new Vector<MeasurementImpl>(measurements);
    }
    
    /**
     * @param measurements the manual measurements to set
     */
    public void setManualMeasurements(List<MeasurementImpl> measurements) {
        this.manualMeasurements = new Vector<MeasurementImpl>(measurements);
    }
    
    public void addManualMeasurement(MeasurementImpl record){
    	this.manualMeasurements.add(record);
    }
    
    /**
     * @return
     */
    public boolean isMarkedAsSuccessful() {
        for( MeasurementImpl m : getMeasurements() ) {
            if( m.getIdentifier().equals( TecRegMockup.PROP_SERVICE_EXECUTION_SUCEEDED.toString() ) ) {
                boolean result = Boolean.parseBoolean( m.getValue() );
                if( result == true ) return true;
            }
        }
        return false;
    }
    
    /**
     * @param propUri
     * @return
     */
    public Double getDoubleMeasurement( URI propUri ) {
        if( propUri == null ) return null;
        for( MeasurementImpl m : getMeasurements() ) {
            if( m.getIdentifier().equals( propUri.toString()  )) {
                return Double.parseDouble(m.getValue());
            }
        }
        return null;
    }

    /**
     * @return the execution
     */
    public ExecutionRecordImpl getExecution() {
        return execution;
    }

    /**
     * @param execution the execution to set
     */
    public void setExecution(ExecutionRecordImpl execution) {
        this.execution = execution;
    }

    /**
     * @return the parameters
     */
    public Set<InvocationParameterImpl> getParameters() {
        return parameters;
    }

    /**
     * @param p
     */
    public void addParameter( Parameter p ) {
        InvocationParameterImpl ip = new InvocationParameterImpl(p);
        ip.setInvocation(this);
        this.parameters.add(ip);
    }

    /**
     * @return the measurements
     */
    public void addMeasurementEvent( MeasurementEventImpl me ) {
        this.measurementEvents.add(me);
        me.setTargetInvocation(this);
        return;
    }

    /**
     * @return
     */
    public Set<MeasurementEventImpl> getMeasurementEvents() {
        return this.measurementEvents;
    }
}
